package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"pillowww/titw/graph"
	"pillowww/titw/graph/converters"
	"pillowww/titw/graph/model"
	"pillowww/titw/models"
)

// Brand is the resolver for the brand field.
func (r *productResolver) Brand(ctx context.Context, obj *model.Product) (*model.Brand, error) {
	brand, err := r.BrandDao.
		FindOneById(ctx, obj.BrandID)

	if err != nil {
		return nil, err
	}

	return converters.BrandToGraphQL(brand), nil
}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *model.Product) (*model.ProductCategory, error) {
	category, err := r.ProductCategoryDao.
		Load(models.ProductCategoryRels.ProductCategoryLanguages).
		FindCategoryById(ctx, obj.ProductCategoryID)

	if err != nil {
		return nil, err
	}

	return converters.ProductCategoryToGraphQL(category), err
}

// ProductSpecificationValues is the resolver for the productSpecificationValues field.
func (r *productResolver) ProductSpecificationValues(ctx context.Context, obj *model.Product) ([]*model.ProductSpecificationValue, error) {
	values, err := r.ProductSpecificationValueDao.FindByProductId(ctx, obj.ID)

	if err != nil {
		return nil, err
	}

	var graphValues []*model.ProductSpecificationValue

	for _, val := range values {
		graphValues = append(
			graphValues,
			converters.ProductSpecificationValueToGraphQL(val),
		)
	}

	return graphValues, nil
}

// Specifications is the resolver for the specifications field.
func (r *productCategoryResolver) Specifications(ctx context.Context, obj *model.ProductCategory) ([]*model.ProductSpecification, error) {
	specs, err := r.ProductSpecificationDao.
		Load(models.ProductSpecificationRels.ProductSpecificationLanguages).
		FindByCategoryId(ctx, obj.ID)

	if err != nil {
		return nil, err
	}

	var graphSpecs []*model.ProductSpecification

	for _, spec := range specs {
		graphSpecs = append(
			graphSpecs,
			converters.ProductSpecificationToGraphQL(spec),
		)
	}

	return graphSpecs, nil
}

// Product is the resolver for the product field.
func (r *productItemResolver) Product(ctx context.Context, obj *model.ProductItem) (*model.Product, error) {
	p, err := r.ProductDao.FindOneById(ctx, obj.ProductID)

	if err != nil {
		return nil, err
	}

	return converters.ProductToGraphQL(p), nil
}

// Price is the resolver for the price field.
func (r *productItemResolver) Price(ctx context.Context, obj *model.ProductItem) ([]*model.ProductPrice, error) {
	item, err := r.ProductItemDao.
		Load(models.ProductItemRels.ProductItemPrices).
		FindProductItemById(ctx, obj.ID)

	if err != nil {
		return nil, err
	}

	var graphPrices []*model.ProductPrice
	prices := item.R.ProductItemPrices

	for _, price := range prices {
		p, err := converters.ProductItemPriceToGraphQL(price)

		if err != nil {
			return nil, err
		}

		graphPrices = append(
			graphPrices,
			p,
		)
	}

	return graphPrices, nil
}

// Supplier is the resolver for the supplier field.
func (r *productItemResolver) Supplier(ctx context.Context, obj *model.ProductItem) (*model.Supplier, error) {
	sup, err := r.SupplierDao.FindOneById(ctx, obj.SupplierID)

	if err != nil {
		return nil, err
	}

	return converters.SupplierToGraphQL(sup), nil
}

// SearchByProductCode is the resolver for the searchByProductCode field.
func (r *queryResolver) SearchByProductCode(ctx context.Context, code string) (*model.ProductItem, error) {
	pItem, err := r.ProductItemDao.FindLessExpensiveByProductCode(ctx, code)

	if err != nil {
		return nil, err
	}

	return converters.ProductItemToGraphQL(pItem), nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, input []*model.ProductSpecificationInput) ([]*model.ProductItem, error) {
	panic(fmt.Errorf("not implemented: Search - search"))
}

// Product returns graph.ProductResolver implementation.
func (r *Resolver) Product() graph.ProductResolver { return &productResolver{r} }

// ProductCategory returns graph.ProductCategoryResolver implementation.
func (r *Resolver) ProductCategory() graph.ProductCategoryResolver {
	return &productCategoryResolver{r}
}

// ProductItem returns graph.ProductItemResolver implementation.
func (r *Resolver) ProductItem() graph.ProductItemResolver { return &productItemResolver{r} }

type productResolver struct{ *Resolver }
type productCategoryResolver struct{ *Resolver }
type productItemResolver struct{ *Resolver }
