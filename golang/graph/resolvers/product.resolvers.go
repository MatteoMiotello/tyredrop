package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.28

import (
	"context"
	"pillowww/titw/graph"
	"pillowww/titw/graph/converters"
	"pillowww/titw/graph/model"
	"pillowww/titw/internal/auth"
	"pillowww/titw/internal/currency"
	"pillowww/titw/models"

	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

// Brand is the resolver for the brand field.
func (r *productResolver) Brand(ctx context.Context, obj *model.Product) (*model.Brand, error) {
	brand, err := r.BrandDao.
		FindOneById(ctx, obj.BrandID)

	if err != nil {
		return nil, err
	}

	return converters.BrandToGraphQL(brand), nil
}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *model.Product) (*model.ProductCategory, error) {
	lang := auth.CurrentLanguage(ctx)

	category, err := r.ProductCategoryDao.
		Load(
			models.ProductCategoryRels.ProductCategoryLanguages,
			models.ProductCategoryLanguageWhere.LanguageID.EQ(lang.L.ID),
		).
		FindCategoryById(ctx, obj.ProductCategoryID)

	if err != nil {
		return nil, err
	}

	return converters.ProductCategoryToGraphQL(category), err
}

// ProductSpecificationValues is the resolver for the productSpecificationValues field.
func (r *productResolver) ProductSpecificationValues(ctx context.Context, obj *model.Product) ([]*model.ProductSpecificationValue, error) {
	values, err := r.ProductSpecificationValueDao.FindByProductId(ctx, obj.ID)

	var graphValues []*model.ProductSpecificationValue

	if err != nil {
		return graphValues, err
	}

	for _, val := range values {
		graphValues = append(
			graphValues,
			converters.ProductSpecificationValueToGraphQL(val),
		)
	}

	return graphValues, nil
}

// VehicleType is the resolver for the vehicleType field.
func (r *productResolver) VehicleType(ctx context.Context, obj *model.Product) (*model.VehicleType, error) {
	vType, err := r.VehicleDao.Load(models.VehicleTypeRels.VehicleTypeLanguages).FindById(ctx, obj.VehicleTypeID)

	if err != nil {
		return nil, err
	}

	return converters.VehicleTypeToGraphQL(vType), nil
}

// Specifications is the resolver for the specifications field.
func (r *productCategoryResolver) Specifications(ctx context.Context, obj *model.ProductCategory) ([]*model.ProductSpecification, error) {
	lang := auth.CurrentLanguage(ctx)

	specs, err := r.ProductSpecificationDao.
		Load(
			models.ProductSpecificationRels.ProductSpecificationLanguages,
			models.ProductSpecificationLanguageWhere.LanguageID.EQ(lang.L.ID),
		).
		FindByCategoryId(ctx, obj.ID)

	var graphSpecs []*model.ProductSpecification
	if err != nil {
		return graphSpecs, err
	}

	for _, spec := range specs {
		graphSpecs = append(
			graphSpecs,
			converters.ProductSpecificationToGraphQL(spec),
		)
	}

	return graphSpecs, nil
}

// Product is the resolver for the product field.
func (r *productItemResolver) Product(ctx context.Context, obj *model.ProductItem) (*model.Product, error) {
	p, err := r.ProductDao.FindOneById(ctx, obj.ProductID)

	if err != nil {
		return nil, err
	}

	return converters.ProductToGraphQL(p), nil
}

// Price is the resolver for the price field.
func (r *productItemResolver) Price(ctx context.Context, obj *model.ProductItem) ([]*model.ProductItemPrice, error) {
	defLang := auth.CurrentLanguage(ctx)

	item, err := r.ProductItemDao.
		WithDeletes().
		Load(
			qm.Rels(
				models.ProductItemRels.ProductItemPrices,
				models.ProductItemPriceRels.Currency,
				models.CurrencyRels.CurrencyLanguages,
			),
			models.CurrencyLanguageWhere.LanguageID.EQ(defLang.L.ID),
		).
		FindProductItemById(ctx, obj.ID)

	if err != nil {
		return nil, err
	}

	var graphPrices []*model.ProductItemPrice
	prices := item.R.ProductItemPrices

	for _, price := range prices {
		p, err := converters.ProductItemPriceToGraphQL(price)

		if err != nil {
			return nil, err
		}

		graphPrices = append(
			graphPrices,
			p,
		)
	}

	return graphPrices, nil
}

// Supplier is the resolver for the supplier field.
func (r *productItemResolver) Supplier(ctx context.Context, obj *model.ProductItem) (*model.Supplier, error) {
	sup, err := r.SupplierDao.FindOneById(ctx, obj.SupplierID)

	if err != nil {
		return nil, err
	}

	return converters.SupplierToGraphQL(sup), nil
}

// SupplierPrice is the resolver for the supplierPrice field.
func (r *productItemResolver) SupplierPrice(ctx context.Context, obj *model.ProductItem) (float64, error) {
	curr, err := r.CurrencyDao.FindDefault(ctx)

	if err != nil {
		return 0, err
	}

	i, err := r.ProductItemDao.FindProductItemById(ctx, obj.ID)

	if err != nil {
		return 0, err
	}

	return currency.ToFloat(i.SupplierPrice, curr.IsoCode)
}

// ProductItem is the resolver for the productItem field.
func (r *productItemPriceResolver) ProductItem(ctx context.Context, obj *model.ProductItemPrice) (*model.ProductItem, error) {
	dbModel, err := r.ProductItemDao.FindProductItemById(ctx, obj.ProductItemID)

	if err != nil {
		return nil, err
	}

	return converters.ProductItemToGraphQL(dbModel), nil
}

// PriceAdditions is the resolver for the priceAdditions field.
func (r *productItemPriceResolver) PriceAdditions(ctx context.Context, obj *model.ProductItemPrice) ([]*model.ProductItemPriceAddition, error) {
	additions, err := r.ProductItemPriceDao.
		Load(qm.Rels(
			models.ProductItemPriceAdditionRels.ProductItemPrice,
			models.PriceAdditionTypeRels.Currency,
		)).
		FindPriceAdditionsByProductItemPriceID(ctx, obj.ID)

	if err != nil {
		return nil, err
	}

	var graphModels []*model.ProductItemPriceAddition

	for _, add := range additions {
		a, err := converters.ProductItemPriceAdditionToGraphQL(add)

		if err != nil {
			return nil, err
		}

		graphModels = append(graphModels, a)
	}

	return graphModels, nil
}

// Product returns graph.ProductResolver implementation.
func (r *Resolver) Product() graph.ProductResolver { return &productResolver{r} }

// ProductCategory returns graph.ProductCategoryResolver implementation.
func (r *Resolver) ProductCategory() graph.ProductCategoryResolver {
	return &productCategoryResolver{r}
}

// ProductItem returns graph.ProductItemResolver implementation.
func (r *Resolver) ProductItem() graph.ProductItemResolver { return &productItemResolver{r} }

// ProductItemPrice returns graph.ProductItemPriceResolver implementation.
func (r *Resolver) ProductItemPrice() graph.ProductItemPriceResolver {
	return &productItemPriceResolver{r}
}

type productResolver struct{ *Resolver }
type productCategoryResolver struct{ *Resolver }
type productItemResolver struct{ *Resolver }
type productItemPriceResolver struct{ *Resolver }
