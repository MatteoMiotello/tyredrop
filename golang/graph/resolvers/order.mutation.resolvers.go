package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"database/sql"
	"errors"
	"pillowww/titw/graph/converters"
	"pillowww/titw/graph/graphErrors"
	"pillowww/titw/graph/model"
	"pillowww/titw/graph/policies"
	"pillowww/titw/internal/auth"
	"pillowww/titw/internal/currency"
	"pillowww/titw/internal/db"
	"pillowww/titw/internal/domain/order"
	"pillowww/titw/internal/domain/payment"
	"pillowww/titw/internal/domain/product"
	"pillowww/titw/internal/email/mailer"
	"pillowww/titw/models"
	"pillowww/titw/pkg/log"

	null "github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

// OrderSupport is the resolver for the orderSupport field.
func (r *mutationResolver) OrderSupport(ctx context.Context, orderID int64, message string) (*model.Order, error) {
	u, err := auth.CurrentUser(ctx)

	if err != nil {
		return nil, err
	}

	o, err := r.OrderDao.
		Load(models.OrderRels.Currency).
		FindOneById(ctx, orderID)

	if err != nil {
		return nil, err
	}

	om := mailer.NewOrderMailer(o)
	err = om.SendSupportEmail(u, message)
	if err != nil {
		log.Error("Error sending order support email", err)
		return nil, graphErrors.NewGraphError(ctx, err, "ERROR_SENDING_EMAIL")
	}

	return converters.OrderToGraphQL(o)
}

// ConfirmOrder is the resolver for the confirmOrder field.
func (r *mutationResolver) ConfirmOrder(ctx context.Context, orderID int64) (*model.Order, error) {
	o, err := r.OrderDao.
		Load(
			models.OrderRels.Currency,
		).
		FindOneById(ctx, orderID)

	if err != nil {
		return nil, err
	}

	policy := policies.NewOrderPolicy(o, r.OrderDao)

	if !policy.CanConfirm(ctx) {
		return nil, graphErrors.NewGraphError(ctx, errors.New("Order can't be confirmed"), "UNABLE_TO_PAY_ORDER")
	}

	s := order.NewService(r.OrderDao, r.CurrencyDao, r.ProductItemDao, r.ProductItemPriceDao)

	err = s.ConfirmOrder(ctx, o)

	if err != nil {
		return nil, err
	}

	return converters.OrderToGraphQL(o)
}

// PayOrder is the resolver for the payOrder field.
func (r *mutationResolver) PayOrder(ctx context.Context, orderID int64, paymentMethodCode string) (*model.Order, error) {
	o, err := r.OrderDao.
		Load(
			models.OrderRels.Currency,
		).
		FindOneById(ctx, orderID)

	if err != nil {
		return nil, err
	}

	policy := policies.NewOrderPolicy(o, r.OrderDao)

	if !policy.CanPay(ctx) {
		return nil, graphErrors.NewGraphError(ctx, errors.New("Order can't be payed"), "UNABLE_TO_PAY_ORDER")
	}

	method, err := r.PaymentDao.FindPaymentMethodByCode(ctx, paymentMethodCode)

	err = db.WithTx(ctx, func(tx *sql.Tx) error {
		oDao := order.NewDao(tx)
		currencyDao := currency.NewDao(tx)
		itemDao := product.NewItemDao(tx)
		itemPriceDao := product.NewItemPriceDao(tx)

		oService := order.NewService(
			oDao,
			currencyDao,
			itemDao,
			itemPriceDao,
		)

		service := payment.NewService(
			payment.NewDao(tx),
			oDao,
		)

		p, err := service.CreatePayment(ctx, o, method)

		if err != nil {
			return err
		}

		err = oService.PayOrder(ctx, o, p)

		if err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return converters.OrderToGraphQL(o)
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID int64, newStatus model.OrderStatus) (*model.Order, error) {
	oService := order.NewService(
		r.OrderDao,
		r.CurrencyDao,
		r.ProductItemDao,
		r.ProductItemPriceDao,
	)

	o, err := r.OrderDao.
		Load(
			models.OrderRels.Currency,
		).
		FindOneById(ctx, orderID)

	if err != nil {
		return nil, err
	}

	err = oService.UpdateOrderStatus(ctx, o, newStatus)

	if err != nil {
		return nil, err
	}

	return converters.OrderToGraphQL(o)
}

// UpdateOrderRow is the resolver for the updateOrderRow field.
func (r *mutationResolver) UpdateOrderRow(ctx context.Context, rowID int64, input model.OrderRowInput) (*model.OrderRow, error) {
	or, err := r.OrderDao.
		Load(qm.Rels(
			models.OrderRowRels.Order,
			models.OrderRels.Currency,
		)).
		FindOrderRowById(ctx, rowID)

	if err != nil {
		return nil, err
	}

	if input.TrackingNumber == nil {
		return converters.OrderRowToGraphQL(or, or.R.Order.R.Currency)
	}

	or.TrackingNumber = null.StringFromPtr(input.TrackingNumber)

	err = r.OrderDao.Save(ctx, or)

	if err != nil {
		return nil, err
	}

	return converters.OrderRowToGraphQL(or, or.R.Order.R.Currency)
}
